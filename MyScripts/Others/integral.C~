Double_t GF = 1.1E-11; // MeV^-2                                                                         
Double_t cos2ThetaC = 0.9471;
Double_t fPi = 130.41; // MeV                                                                            
Double_t fRho = 1.04E5; // MeV^2                                                                         
Double_t e = 0.511;
Double_t mu = 105.66;
Double_t tau = 1776.82;
Double_t pi = 139.57;
Double_t pi0 = 134.98;
Double_t rho = 775.4;
Double_t D = 1869.62;
Double_t DS = 1968.28;
Double_t D0 = 1864.84;
Double_t K = 493.68;
Double_t K0 = 497.61;
//Double_t Dlife = 1.04E-12;                                                                             
//Double_t D0life = 4.101E-13;                                                                           
Double_t Dlife = 1.04E-3;
Double_t D0life = 4.101E-4;
Double_t DSlife = 5.E-4;
Double_t taulife = 2.91E-4;
Double_t Vcs = 0.9734;
Double_t Vcd = 0.2252;
Double_t Vud = 0.9743;
Double_t fD = 222.6;
Double_t fDS = 280.1;
Double_t fDK0 = 0.725;
Double_t fDpi0 = 0.146;
Double_t fD0K = 0.736;
Double_t fD0pi = 0.637;
Double_t De2BR = 9.2E-9;
Double_t Dm2BR = 3.74E-4;
Double_t DSe2BR = 1.4E-7;
Double_t DSm2BR = 5.56E-3;
Double_t DSt2BR = 5.48E-2;
Double_t TauPi2BR = 10.82E-2;
const int InitialMass = 100;
const int Mass = 10000;
const int step = 1;
const int Masses = Mass/step;

Double_t ThreeBodyBR(Double_t Mass1, Double_t Mass2, Double_t Mass3, Double_t Mass4) {

  Double_t ENmin = Mass2; // N at rest, K and e back to back                                            
  Double_t ENmax = (Mass1*Mass1+Mass2*Mass2-TMath::Power(Mass4+Mass3, 2.))/(2.*Mass1); // N one way, K and e other way, their momenta summed equal to the N one                                                 
  Double_t q2min = TMath::Power(Mass2+Mass4, 2.); // sum of masses of lepton pair                      
  Double_t q2max = Mass2*Mass2 + Mass4*Mass4 + 4.*ENmax*ENmax; // sum of 4momenta of lepton pair, when K at rest and N and e back to back                                                                       
  Double_t tau, V, f, a, b;
  Double_t br = 0.;
  f = 0.725;
  /*
  TF1 *func = new TF1("func", "([0]*[0]*(x*([2]*[2] + [4]*[4]) - TMath::Power([2]*[2] - [4]*[4], 2.)) + 2.*[0]*[0]*([2]*[2]*(2.*[1]*[1] - 2.*[3]*[3] -4.*[5]*[1] - [4]*[4] + [2]*[2] + x) + [4]*[4]*(4.*[5]*[1] + [4]*[4] - [2]*[2] - x)) + [0]*[0]*((4.*[5]*[1] + [4]*[4] - [2]*[2] - x)*(2.*[1]*[1] - 2.*[3]*[3] - 4.*[5]*[1] - [4]*[4] + [2]*[2] + x) - (2.*[1]*[1] + 2.*[3]*[3] - x)*(x - [2]*[2] - [4]*[4])))", q2min, q2max);

    func->SetParameter(0, f);
    func->SetParameter(2, Mass2);
    func->SetParameter(4, Mass4);
    func->SetParameter(1, Mass1);
    func->SetParameter(3, Mass3);
    func->SetParameter(5, ENmax);
  */
  /*
  TF1 *func = new TF1("func", "([0]*[0]*(x*([2]*[2] + [4]*[4]) - TMath::Power([2]*[2] - [4]*[4], 2.)))");
  func->SetParameter(0, f);
  func->SetParameter(2, Mass2);
  func->SetParameter(4, Mass4);
  */
  /*
  TF1 *func = new TF1("func", "2.*[0]*[0]*([2]*[2]*(2.*[1]*[1] - 2.*[3]*[3] -4.*[5]*[1] - [4]*[4] + [2]*[2] + x) + [4]*[4]*(4.*[5]*[1] + [4]*[4] - [2]*[2] - x))");
    func->SetParameter(0, f);
    func->SetParameter(2, Mass2);
    func->SetParameter(4, Mass4);
    func->SetParameter(1, Mass1);
    func->SetParameter(3, Mass3);
    func->SetParameter(5, ENmax);
  */
  TF1 *func = new TF1("func", "([0]*[0]*(x*([2]*[2] + [4]*[4]) - TMath::Power([2]*[2] - [4]*[4], 2.)) + 2.*[0]*[0]*([2]*[2]*(2.*[1]*[1] - 2.*[3]*[3] -4.*[5]*[1] - [4]*[4] + [2]*[2] + x) + [4]*[4]*(4.*[5]*[1] + [4]*[4] - [2]*[2] - x)) + [0]*[0]*((4.*[5]*[1] + [4]*[4] - [2]*[2] - x)*(2.*[1]*[1] - 2.*[3]*[3] - 4.*[5]*[1] - [4]*[4] + [2]*[2] + x) - (2.*[1]*[1] + 2.*[3]*[3] - x)*(x - [2]*[2] - [4]*[4])))", q2min, q2max);
    func->SetParameter(0, f);
    func->SetParameter(2, Mass2);
    func->SetParameter(4, Mass4);
    func->SetParameter(1, Mass1);
    func->SetParameter(3, Mass3);
    func->SetParameter(5, ENmax);

  ROOT::Math::WrappedTF1 wf1(*func);
  ROOT::Math::GaussLegendreIntegrator ig;
  ig.SetFunction(wf1);
  b = ig.Integral(q2min, q2max);
  br = b;

  return br;
}

void integral() {
  Double_t BR = 0.;
  Double_t xMN[Masses];
  Double_t yBR[Masses];

  for (Int_t MN = InitialMass; MN < Mass; MN += step) {
    BR = ThreeBodyBR(D, MN, K0, e);
    xMN[MN] = MN/1000.;
    yBR[MN] = BR;
  }

  TGraph* gr = new TGraph(Mass, xMN, yBR);
  gr->Draw();
}
